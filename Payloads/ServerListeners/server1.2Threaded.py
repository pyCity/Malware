#!/usr/bin/env python3
"""
Author       - pyCity
Date         - 3/14/2019
Version      - 1.2

Usage:       - python server.py --enc 127.0.0.1 4444
             - Run setup.sh to generate certs

Description: - Threaded, Multi-Handler for client.py Supports TLS encryption
               using a DHE-RSA-AES256-SHA256 cipher.
"""

import ssl
import socket
import argparse
import threading

from time import sleep


class ClientThread(threading.Thread):
    def __init__(self, sock, ip, port):
        threading.Thread.__init__(self)
        self.sock = sock
        self.ip = ip
        self.port = port
        print("New thread started for {} {}".format(self.ip, self.port))
        self.run_thread()

    def run_thread(self):
        while True:
            try:
                # cmd = "id"
                # print("Sending {} to {}".format(cmd, self.ip))
                # self.sock.send(cmd.encode("utf-8"))
                # print(str(self.sock.recv(1024)))
                # sleep(2)
                self.sock.send("kill".encode("utf-8"))  # This is specific to client1.2
                print(str(self.sock.recv(1024)))
                self.sock.close()
                break
            except OSError as err:
                print(err)


class Server:

    def __init__(self, host, port, enc=False):
        self.host = host
        self.port = port
        self.enc = enc
        try:
            self.sock = socket.socket()
        except socket.error as hell:
            raise hell
        self.wrap_sock()

    def wrap_sock(self):
        try:
            if self.enc:
                print("TLS encryption enabled")
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                context.set_ciphers('DHE-RSA-AES256-SHA256')
                context.load_dh_params("dhparam.pem")
                context.load_cert_chain(certfile="server.crt", keyfile="server.key")
                self.sock = context.wrap_socket(self.sock, do_handshake_on_connect=True, server_side=True)
        except socket.error as err:
            exit("Error creating socket: {}".format(str(err)))
            self.sock.close()

    def bind_sock(self):
        attempts, max = 0, 10
        while attempts < max:
            try:
                print("Binding socket to port {}".format(str(self.port)))
                self.sock.bind((self.host, self.port))
                self.sock.listen(10)
                return self.sock
            except socket.error as msg:
                print("Error binding socket: {}\n  Retrying...".format(str(msg)))
                sleep(3)
                attempts += 1


def main():
    parser = argparse.ArgumentParser(description="Python TCP server with TLS encryption")
    parser.add_argument("host", help="IP address to bind for listening")
    parser.add_argument("port", help="Port to bind for listening", type=int)
    parser.add_argument("cmd", help="Command to send to remote server", action="store_true")
    parser.add_argument("--enc", help="Enable TLS encryption", action="store_true")
    args = parser.parse_args()

    threads = []

    srv_sock = Server(args.host, args.port, args.enc)
    sock = srv_sock.bind_sock()

    while True:

        try:
            print("Listening for connections..")
            conn, address = sock.accept()

            print("Connection established from: {} {}".format(address[0], str(address[1])))
            new_thread = ClientThread(conn, address[0], address[1])  # False
            new_thread.start()
            threads.append(new_thread)

            for t in threads:
                print("Killing thread: {}".format(t))
                t.join()

        except OSError as err:
            print("Connection Failure: {}".format(err))
        except KeyboardInterrupt:
            sock.close()
            exit("Keyboard Interrupt detected. Exiting")


main()
